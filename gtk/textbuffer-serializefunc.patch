--- generated-trunk/TextBufferSerializeFunc.cs	2009-11-16 14:50:34.000000000 -0800
+++ TextBufferSerializeFunc.cs	2009-11-16 15:01:15.000000000 -0800
@@ -1,10 +1,11 @@
-// This file was generated by the Gtk# code generator.
-// Any changes made will be lost if regenerated.
+// This file was auto-generated at one time, but is hardcoded here as part of the fix
+// for the TextBufferSerializeFunc;  see https://bugzilla.novell.com/show_bug.cgi?id=555495
+// The generated code may have been modified as part of this fix; see textbuffer-serializefunc.patch
 
 namespace Gtk {
 
 	using System;
 
-	public delegate byte TextBufferSerializeFunc(Gtk.TextBuffer register_buffer, Gtk.TextBuffer content_buffer, Gtk.TextIter start, Gtk.TextIter end, out ulong length);
+	public delegate byte [] TextBufferSerializeFunc(Gtk.TextBuffer register_buffer, Gtk.TextBuffer content_buffer, Gtk.TextIter start, Gtk.TextIter end, out ulong length);
 
 }
--- generated-trunk/GtkSharp.TextBufferSerializeFuncNative.cs	2009-11-16 14:50:35.000000000 -0800
+++ GtkSharp.TextBufferSerializeFuncNative.cs	2009-11-16 15:17:14.000000000 -0800
@@ -1,14 +1,14 @@
-// This file was generated by the Gtk# code generator.
-// Any changes made will be lost if regenerated.
+// This file was auto-generated at one time, but is hardcoded here as part of the fix
+// for the TextBufferSerializeFunc;  see https://bugzilla.novell.com/show_bug.cgi?id=555495
+// The generated code may have been modified as part of this fix; see textbuffer-serializefunc.patch
 
 namespace GtkSharp {
 
 	using System;
 	using System.Runtime.InteropServices;
 
-#region Autogenerated code
 	[GLib.CDeclCallback]
-	internal delegate byte TextBufferSerializeFuncNative(IntPtr register_buffer, IntPtr content_buffer, IntPtr start, IntPtr end, out UIntPtr length, IntPtr user_data);
+	internal delegate IntPtr TextBufferSerializeFuncNative(IntPtr register_buffer, IntPtr content_buffer, IntPtr start, IntPtr end, out UIntPtr length, IntPtr user_data);
 
 	internal class TextBufferSerializeFuncInvoker {
 
@@ -40,34 +40,55 @@
 			}
 		}
 
-		byte InvokeNative (Gtk.TextBuffer register_buffer, Gtk.TextBuffer content_buffer, Gtk.TextIter start, Gtk.TextIter end, out ulong length)
+		private static readonly byte [] empty_byte_array = new byte[0];
+		byte [] InvokeNative (Gtk.TextBuffer register_buffer, Gtk.TextBuffer content_buffer, Gtk.TextIter start, Gtk.TextIter end, out ulong length)
 		{
 			IntPtr native_start = GLib.Marshaller.StructureToPtrAlloc (start);
 			IntPtr native_end = GLib.Marshaller.StructureToPtrAlloc (end);
 			UIntPtr native_length;
-			byte result = native_cb (register_buffer == null ? IntPtr.Zero : register_buffer.Handle, content_buffer == null ? IntPtr.Zero : content_buffer.Handle, native_start, native_end, out native_length, __data);
+			IntPtr result_ptr = native_cb (register_buffer == null ? IntPtr.Zero : register_buffer.Handle, content_buffer == null ? IntPtr.Zero : content_buffer.Handle, native_start, native_end, out native_length, __data);
 			start = Gtk.TextIter.New (native_start);
 			Marshal.FreeHGlobal (native_start);
 			end = Gtk.TextIter.New (native_end);
 			Marshal.FreeHGlobal (native_end);
 			length = (ulong) native_length;
-			return result;
+
+			byte [] result = null;
+			if (length > 0 && result_ptr != IntPtr.Zero) {
+					result = new byte [length];
+					Marshal.Copy (result_ptr, result, 0, (int)length);
+			}
+
+			if (result_ptr != IntPtr.Zero) {
+				GLib.Marshaller.Free (result_ptr);
+			}
+
+			return result == null ? empty_byte_array : result;
 		}
 	}
 
 	internal class TextBufferSerializeFuncWrapper {
 
-		public byte NativeCallback (IntPtr register_buffer, IntPtr content_buffer, IntPtr start, IntPtr end, out UIntPtr length, IntPtr user_data)
+		public IntPtr NativeCallback (IntPtr register_buffer, IntPtr content_buffer, IntPtr start, IntPtr end, out UIntPtr length, IntPtr user_data)
 		{
 			try {
 				ulong mylength;
 
-				byte __ret = managed (GLib.Object.GetObject(register_buffer) as Gtk.TextBuffer, GLib.Object.GetObject(content_buffer) as Gtk.TextBuffer, Gtk.TextIter.New (start), Gtk.TextIter.New (end), out mylength);
+				byte [] __ret = managed (GLib.Object.GetObject(register_buffer) as Gtk.TextBuffer, GLib.Object.GetObject(content_buffer) as Gtk.TextBuffer, Gtk.TextIter.New (start), Gtk.TextIter.New (end), out mylength);
+
 				length = new UIntPtr (mylength);
 
+				IntPtr ret_ptr;
+				if (mylength > 0) {
+					ret_ptr = GLib.Marshaller.Malloc ((ulong)(Marshal.SizeOf (typeof(byte)) * (int)mylength));
+					Marshal.Copy (__ret, 0, ret_ptr, (int)mylength);
+				} else {
+					ret_ptr = IntPtr.Zero;
+				}
+
 				if (release_on_call)
 					gch.Free ();
-				return __ret;
+				return ret_ptr;
 			} catch (Exception e) {
 				GLib.ExceptionManager.RaiseUnhandledException (e, true);
 				// NOTREACHED: Above call does not return.
@@ -104,5 +125,4 @@
 			return wrapper.managed;
 		}
 	}
-#endregion
 }
