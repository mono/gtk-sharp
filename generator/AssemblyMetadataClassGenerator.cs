// AssemblyMetadataClassGenerator.cs
//
// Author: Antonius Riha <antoniusriha@gmail.com>
//
// Copyright (c) 2014 Antonius Riha
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the GNU General Public
// License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace GtkSharp.Generation
{
	public class AssemblyMetadataClassGenerator
	{
		readonly string dir;

		readonly List<LibraryNameHandle> libraries;

		string className;

		public AssemblyMetadataClassGenerator (string dir)
		{
			if (dir == null) {
				throw new ArgumentNullException ("dir");
			}

			this.dir = dir;
			libraries = new List<LibraryNameHandle> ();
		}

		public LibraryNameHandle AddLibrary (string libraryName)
		{
			var handle = libraries.SingleOrDefault (h => h.LibraryName == libraryName);
			if (handle == null) {
				handle = new LibraryNameHandle (this, libraryName);
				libraries.Add (handle);
			}

			return handle;
		}

		public void Generate (IEnumerable<IGeneratable> gens)
		{
			// Determine the class name. Make sure not to pick a name that is already a type in the assembly.
			var generatables = gens.ToList ();
			className = "AssemblyMetadata";
			for (var i = 2; i < int.MaxValue && generatables.Any (g => g.Name == className); i++) {
				className += i;
			}

			// Make sure that the directory exists
			Directory.CreateDirectory (dir);

			// Generate the actual class code.
			var path = Path.Combine (dir, className + ".cs");
			using (var sw = new StreamWriter (path)) {
				sw.WriteLine ("// This file was generated by the Gtk# code generator.");
				sw.WriteLine ("// Any changes made will be lost if regenerated.");
				sw.WriteLine ();
				sw.WriteLine ("internal static partial class " + className + " {");

				foreach (var item in libraries) {
					sw.WriteLine ("\tinternal const string " + item.ConstName + " = \"" + item.LibraryName + "\";");
				}

				sw.WriteLine ("}");
			}
		}

		public string GetClassName ()
		{
			if (className == null) {
				throw new InvalidOperationException (
					"Class name has not yet been determined. Call AssemblyMetadataClassGenerator.Generate for that.");
			}

			return className;
		}
	}

	public class LibraryNameHandle
	{
		readonly AssemblyMetadataClassGenerator metadataClassGen;

		readonly string libraryName;

		readonly string constName;

		public LibraryNameHandle (AssemblyMetadataClassGenerator metadataClassGen, string libraryName)
		{
			if (metadataClassGen == null) {
				throw new ArgumentNullException ("metadataClassGen");
			}

			if (libraryName == null) {
				throw new ArgumentNullException ("libraryName");
			}

			this.metadataClassGen = metadataClassGen;
			this.libraryName = libraryName;
			constName = BuildConstName (libraryName);
		}

		public string LibraryName {
			get { return libraryName; }
		}

		public string ConstName {
			get { return constName; }
		}

		public string GetLibraryNameExpression ()
		{
			return metadataClassGen.GetClassName () + "." + ConstName;
		}

		static string BuildConstName (string libraryName)
		{
			// Remove prefix [L|l]ib
			if (libraryName.StartsWith ("lib", StringComparison.InvariantCultureIgnoreCase)) {
				libraryName = libraryName.Substring (3, libraryName.Length - 3);
			}

			// Remove trailing .dll, .dylib or .so
			if (libraryName.EndsWith (".dll", StringComparison.InvariantCultureIgnoreCase)) {
				libraryName = libraryName.Substring (0, libraryName.Length - 4);
			} else if (libraryName.EndsWith (".dylib", StringComparison.InvariantCultureIgnoreCase)) {
				libraryName = libraryName.Substring (0, libraryName.Length - 6);
			} else {
				// Remove trailing .so, .so.X, .so.X.Y, .so.X.Y.Z, etc.
				libraryName = Regex.Replace(libraryName, @"\.so(\.\d+)*$", "");
			}

			// Remove invalid characters
			libraryName = libraryName.Replace ("-", "").Replace (".", "");

			// Make first letter upper case
			libraryName = libraryName [0].ToString ().ToUpperInvariant () +
				libraryName.Substring (1, libraryName.Length - 1);

			return "Native" + libraryName;
		}
	}
}
